// Copyright 2017 ZhongAn Information Technology Services Co.,Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

import (
	"time"

	pbtypes "github.com/Baptist-Publication/chorus/angine/protos/types"
	"github.com/Baptist-Publication/chorus/eth/common/hexutil"
	"github.com/Baptist-Publication/chorus/eth/common/number"
	ethtypes "github.com/Baptist-Publication/chorus/eth/core/types"
	"github.com/Baptist-Publication/chorus/module/lib/go-crypto"
	"github.com/Baptist-Publication/chorus/module/lib/go-p2p"
	"github.com/Baptist-Publication/chorus/module/lib/go-rpc/types"
	"github.com/Baptist-Publication/chorus/module/lib/go-wire"
	"github.com/Baptist-Publication/chorus/module/xlib/def"
	"github.com/Baptist-Publication/chorus/types"
)

// ResultBlockMeta simply duplicates pbtypes.BlockMeta but change the way to marshal []byte.
// So we will not change the structs generated by protobuf.
// By default, go json encodes []byte as base64. In our response it will be a plain HEX string prefixed by 0x.
// Meanwhile changed json key names to lowercase for better naming convention
type ResultBlockMeta struct {
	Hash hexutil.Bytes `json:"hash"`
	// removed for duplication
	//Header      *ResultHeader        `json:"header,"
	PartsHeader *ResultPartSetHeader `json:"parts_header"`
}

func (r *ResultBlockMeta) Adapt(m *pbtypes.BlockMeta) *ResultBlockMeta {
	if m == nil {
		return nil
	}
	r.Hash = m.Hash
	//r.Header = (&ResultHeader{}).Adapt(m.Header)
	r.PartsHeader = (&ResultPartSetHeader{}).Adapt(m.PartsHeader)
	return r
}

type ResultBlock struct {
	Header     *ResultHeader       `json:"header"`
	Data       *ResultData         `json:"data"`
	LastCommit *ResultCommit       `json:"last_commit"`
	VSet       *ResultValidatorSet `json:"validator_set"`
}

type ResultValidator struct {
	Address     hexutil.Bytes `json:"address"`
	PubKey      hexutil.Bytes `json:"pub_key"`
	VotingPower def.INT       `json:"voting_power"`
	Accum       def.INT       `json:"accum"`
	IsCA        bool          `json:"is_ca"`
}

func (r *ResultValidator) Adapt(m *Validator) *ResultValidator {
	if m == nil {
		return nil
	}
	r.Accum = m.Accum
	r.Address = m.Address
	r.IsCA = m.IsCA
	r.PubKey = hexutil.Bytes(m.PubKey.Bytes())
	r.VotingPower = m.VotingPower
	return r
}

type ResultValidatorSet struct {
	Validators       []*ResultValidator `json:"validators"`
	Proposer         *ResultValidator   `json:"proposer"`
	TotalVotingPower def.INT            `json:"total_voting_power"`
}

func (r *ResultValidatorSet) Adapt(m *pbtypes.ValidatorSet) *ResultValidatorSet {
	if m == nil {
		return nil
	}
	rv := ValSetFromPb(m)

	if rv.Validators != nil {
		r.Validators = make([]*ResultValidator, len(rv.Validators))

		for i, validator := range rv.Validators {
			r.Validators[i] = new(ResultValidator).Adapt(validator)
		}
	}

	r.Proposer = new(ResultValidator).Adapt(rv.proposer)
	r.TotalVotingPower = rv.totalVotingPower

	return r
}

func (r *ResultBlock) Adapt(m *pbtypes.Block) *ResultBlock {
	if m == nil {
		return nil
	}
	r.Header = (&ResultHeader{}).Adapt(m.Header)
	r.Data = (&ResultData{}).Adapt(m.Data)
	r.LastCommit = (&ResultCommit{}).Adapt(m.LastCommit)
	r.VSet = (&ResultValidatorSet{}).Adapt(m.VSet)
	return r
}

// ResultHeader duplicates pbtypes.Header
type ResultHeader struct {
	ChainID            string         `json:"chain_id"`
	Height             int64          `json:"height"`
	Time               int64          `json:"time"`
	NumTxs             int64          `json:"num_txs"`
	Maker              hexutil.Bytes  `json:"maker"`
	LastBlockID        *ResultBlockID `json:"last_block_id"`
	LastCommitHash     hexutil.Bytes  `json:"last_commit_hash"`
	DataHash           hexutil.Bytes  `json:"data_hash"`
	ValidatorsHash     hexutil.Bytes  `json:"validators_hash"`
	AppHash            hexutil.Bytes  `json:"app_hash"`
	ReceiptsHash       hexutil.Bytes  `json:"receipts_hash"`
	LastNonEmptyHeight int64          `json:"last_non_empty_height"`
	CoinBase           hexutil.Bytes  `json:"coin_base"`
}

func (r *ResultHeader) Adapt(m *pbtypes.Header) *ResultHeader {
	if m == nil {
		return nil
	}
	r.ChainID = m.ChainID
	r.Height = m.Height
	r.Time = m.Time
	r.NumTxs = m.NumTxs
	r.Maker = m.Maker
	r.LastBlockID = (&ResultBlockID{}).Adapt(m.LastBlockID)
	r.LastCommitHash = m.LastCommitHash
	r.DataHash = m.DataHash
	r.ValidatorsHash = m.ValidatorsHash
	r.AppHash = m.AppHash
	r.ReceiptsHash = m.ReceiptsHash
	r.LastNonEmptyHeight = m.LastNonEmptyHeight
	r.CoinBase = m.CoinBase
	return r
}

type ResultData struct {
	//Txs   []hexutil.Bytes `json:"txs"`
	//ExTxs []hexutil.Bytes `json:"ex_txs"`
	// Return the hash of the transactions
	// Use another call to get the details
	Txs   []hexutil.Bytes `json:"txs"`
	ExTxs []hexutil.Bytes `json:"ex_txs"`
}

func (r *ResultData) Adapt(m *pbtypes.Data) *ResultData {
	if m == nil {
		return nil
	}

	txs := BytesToTxSlc(m.Txs)
	r.Txs = make([]hexutil.Bytes, len(txs))
	for i, tx := range txs {
		r.Txs[i] = hexutil.Bytes(tx.TxHash())
	}

	extxs := BytesToTxSlc(m.ExTxs)
	r.ExTxs = make([]hexutil.Bytes, len(extxs))
	for i, tx := range extxs {
		r.ExTxs[i] = hexutil.Bytes(tx.TxHash())
	}
	return r
}

type ResultCommit struct {
	BlockID    *ResultBlockID `json:"block_id"`
	Precommits []*ResultVote  `json:"pre_commits"`
}

func (r *ResultCommit) Adapt(m *pbtypes.Commit) *ResultCommit {
	if m == nil {
		return nil
	}
	r.BlockID = (&ResultBlockID{}).Adapt(m.BlockID)
	r.Precommits = make([]*ResultVote, len(m.Precommits))
	for i, resultVote := range m.Precommits {
		r.Precommits[i] = new(ResultVote).Adapt(resultVote)
	}
	return r
}

type ResultBlockID struct {
	Hash        hexutil.Bytes        `json:"hash"`
	PartsHeader *ResultPartSetHeader `json:"parts_header"`
}

func (r *ResultBlockID) Adapt(m *pbtypes.BlockID) *ResultBlockID {
	if m == nil {
		return nil
	}
	r.Hash = m.Hash
	r.PartsHeader = (&ResultPartSetHeader{}).Adapt(m.PartsHeader)
	return r
}

type ResultPartSetHeader struct {
	Total int32         `json:"total"`
	Hash  hexutil.Bytes `json:"hash"`
}

func (r *ResultPartSetHeader) Adapt(m *pbtypes.PartSetHeader) *ResultPartSetHeader {
	if m == nil {
		return nil
	}
	r.Hash = m.Hash
	r.Total = m.Total
	return r
}

type ResultBlockchainInfo struct {
	LastHeight def.INT            `json:"last_height"`
	BlockMetas []*ResultBlockMeta `json:"block_metas"`
}

type ResultGenesis struct {
	Genesis *GenesisDoc `json:"genesis"`
}

type ResultBlockInfo struct {
	BlockMeta *ResultBlockMeta `json:"block_meta"`
	Block     *ResultBlock     `json:"block"`
}

type ResultVote struct {
	Data      *ResultVoteData `json:"data"`
	Signature hexutil.Bytes   `json:"signature"`
}

func (r *ResultVote) Adapt(m *pbtypes.Vote) *ResultVote {
	r.Data = (&ResultVoteData{}).Adapt(m.Data)
	r.Signature = m.Signature
	return r
}

type ResultVoteType int32

type ResultVoteData struct {
	ValidatorAddress hexutil.Bytes  `json:"validator_address"`
	ValidatorIndex   int64          `json:"validator_index"`
	Height           int64          `json:"height"`
	Round            int64          `json:"round"`
	Type             ResultVoteType `json:"type"`
	BlockID          *ResultBlockID `json:"block_id"`
}

func (r *ResultVoteData) Adapt(m *pbtypes.VoteData) *ResultVoteData {
	if m == nil {
		return nil
	}
	r.BlockID = new(ResultBlockID).Adapt(m.BlockID)
	r.Height = m.Height
	r.Round = m.Round
	r.Type = ResultVoteType(m.Type)
	r.ValidatorAddress = m.ValidatorAddress
	r.ValidatorIndex = m.ValidatorIndex
	return r
}

type ResultOrgs struct {
	Names []string `json:"names"`
}

type ResultStatus struct {
	NodeInfo          *p2p.NodeInfo `json:"node_info"`
	PubKey            crypto.PubKey `json:"pub_key"`
	LatestBlockHash   hexutil.Bytes `json:"latest_block_hash"`
	LatestAppHash     hexutil.Bytes `json:"latest_app_hash"`
	LatestBlockHeight def.INT       `json:"latest_block_height"`
	LatestBlockTime   int64         `json:"latest_block_time"` // nano
}

type ResultNetInfo struct {
	Listening bool     `json:"listening"`
	Listeners []string `json:"listeners"`
	Peers     []*Peer  `json:"peers"`
}

type ResultDialSeeds struct {
}

type Peer struct {
	p2p.NodeInfo     `json:"node_info"`
	IsOutbound       bool                 `json:"is_outbound"`
	ConnectionStatus p2p.ConnectionStatus `json:"connection_status"`
}

type ResultValidators struct {
	BlockHeight def.INT      `json:"block_height"`
	Validators  []*Validator `json:"validators"`
}

type ResultDumpConsensusState struct {
	RoundState      string   `json:"round_state"`
	PeerRoundStates []string `json:"peer_round_states"`
}

type ResultBroadcastTx struct {
	Code pbtypes.CodeType `json:"code"`
	Data hexutil.Bytes    `json:"data"`
	Log  string           `json:"log"`
}

type ResultRequestSpecialOP struct {
	Code pbtypes.CodeType `json:"code"`
	Data hexutil.Bytes    `json:"data"`
	Log  string           `json:"log"`
}

type ResultBroadcastTxCommit struct {
	Code pbtypes.CodeType `json:"code"`
	Data hexutil.Bytes    `json:"data"`
	Log  string           `json:"log"`
}

type ResultUnconfirmedTxs struct {
	N   int  `json:"n_txs"`
	Txs []Tx `json:"txs"`
}

type ResultContractPayload struct {
	Code pbtypes.CodeType `json:"code"`
	Data hexutil.Bytes    `json:"data"`
	Log  string           `json:"log"`
}

type ResultInfo struct {
	Data             string        `json:"data"`
	Version          string        `json:"version"`
	LastBlockHeight  def.INT       `json:"last_block_height"`
	LastBlockAppHash hexutil.Bytes `json:"last_block_app_hash"`
}

// ResultQuery is the result for all the raw query interface
type ResultQuery struct {
	Result Result `json:"result"`
}

type ResultQueryNonce struct {
	Code  pbtypes.CodeType `json:"code"`
	Log   string           `json:"log"`
	Nonce uint64           `json:"nonce"`
}

type ResultQueryBalance struct {
	Code    pbtypes.CodeType  `json:"code"`
	Log     string            `json:"log"`
	Balance *number.BigNumber `json:"balance"`
}

type ResultQueryShare struct {
	Code          pbtypes.CodeType  `json:"code"`
	Log           string            `json:"log"`
	ShareBalance  *number.BigNumber `json:"share_balance"`
	ShareGuaranty *number.BigNumber `json:"share_guaranty"`
	GHeight       *number.BigNumber `json:"gheight"`
}

type ResultQueryReceipt struct {
	Code    pbtypes.CodeType  `json:"code"`
	Log     string            `json:"log"`
	Receipt *ethtypes.Receipt `json:"receipt"`
}

type ResultQueryContract struct {
	Code pbtypes.CodeType `json:"code"`
	Data string           `json:"data"`
}

type ResultBlockTx struct {
	GasLimit  *number.BigNumber `json:"gas_limit"`
	GasPrice  *number.BigNumber `json:"gas_price"`
	Nonce     uint64            `json:"nonce"`
	Sender    hexutil.Bytes     `json:"sender"`
	Payload   interface{}       `json:"payload"`
	Signature hexutil.Bytes     `json:"signature"`
	Tx_Type   string            `json:"tx_type"`
}
type ResultQueryTx struct {
	Code pbtypes.CodeType `json:"code"`
	Log  string           `json:"log"`
	Tx   *ResultBlockTx   `json:"tx"`
}

type ResultTxEvmCommon struct {
	To     hexutil.Bytes     `json:"to"`
	Amount *number.BigNumber `json:"amount"`
	Load   hexutil.Bytes     `json:"load"`
}

func (r *ResultTxEvmCommon) Adapt(m *types.TxEvmCommon) *ResultTxEvmCommon {
	r.To = m.To
	r.Load = m.Load
	r.Amount = (*number.BigNumber)(m.Amount)
	return r
}

type ResultTxShareEco struct {
	Source    hexutil.Bytes     `json:"source"`
	Amount    *number.BigNumber `json:"amount"`
	Signature hexutil.Bytes     `json:"signature"`
}

func (r *ResultTxShareEco) Adapt(m *types.TxShareEco) *ResultTxShareEco {
	r.Signature = m.Signature
	r.Source = m.Source
	r.Amount = (*number.BigNumber)(m.Amount)
	return r
}

type ResultTxShareTransfer struct {
	ShareSrc hexutil.Bytes     `json:"share_source"`
	ShareDst hexutil.Bytes     `json:"share_destination"`
	Amount   *number.BigNumber `json:"amount"`
	ShareSig hexutil.Bytes     `json:"share_signature"`
}

func (r *ResultTxShareTransfer) Adapt(m *types.TxShareTransfer) *ResultTxShareTransfer {
	r.ShareSrc = m.ShareSrc
	r.ShareDst = m.ShareDst
	r.ShareSig = m.ShareSig
	r.Amount = (*number.BigNumber)(m.Amount)
	return r
}

type ResultRefuseList struct {
	Result []string `json:"result"`
}

type ResultUnsafeFlushMempool struct{}

type ResultUnsafeSetConfig struct{}

type ResultUnsafeProfile struct{}

type ResultSubscribe struct {
}

type ResultUnsubscribe struct {
}

type ResultEvent struct {
	Name string      `json:"name"`
	Data TMEventData `json:"data"`
}

type ResultSurveillance struct {
	NanoSecsPerTx time.Duration
	Height        def.INT
	Addr          string
	IsValidator   bool
	NumValidators int
	NumPeers      int
	RunningTime   time.Duration
	PubKey        string
}

type ResultCoreVersion struct {
	Version    string `json:"version"`
	AppName    string `json:"appname"`
	AppVersion string `json:"appversion"`
	Hash       string `json:"hash"`
}

type ResultNonEmptyHeights struct {
	Heights []def.INT `json:"heights"`
}

//----------------------------------------
// response & result types

const (
	// 0x0 bytes are for the blockchain
	ResultTypeGenesis         = byte(0x01)
	ResultTypeBlockchainInfo  = byte(0x02)
	ResultTypeBlock           = byte(0x03)
	ResultTypeNonEmptyHeights = byte(0x04)

	// 0x2 bytes are for the network
	ResultTypeStatus    = byte(0x20)
	ResultTypeNetInfo   = byte(0x21)
	ResultTypeDialSeeds = byte(0x22)
	ResultTypeOrgs      = byte(0x23)

	// 0x1  bytes are for refuseList
	ResultTypeRefuseList = byte(0x10)

	// 0x4 bytes are for the consensus
	ResultTypeValidators         = byte(0x40)
	ResultTypeDumpConsensusState = byte(0x41)

	// 0x6 bytes are for txs / the application
	ResultTypeBroadcastTx       = byte(0x60)
	ResultTypeUnconfirmedTxs    = byte(0x61)
	ResultTypeBroadcastTxCommit = byte(0x62)
	ResultTypeRequestSpecialOP  = byte(0x63)

	// 0x7 bytes are for querying the application
	ResultTypeQuery        = byte(0x70)
	ResultTypeInfo         = byte(0x71)
	ResultTypeQueryNonce   = byte(0x72)
	ResultTypeQueryBalance = byte(0x73)
	ResultTypeQueryShare   = byte(0x74)
	ResultTypeQueryReceipt = byte(0x75)

	// 0x8 bytes are for events
	ResultTypeSubscribe   = byte(0x80)
	ResultTypeUnsubscribe = byte(0x81)
	ResultTypeEvent       = byte(0x82)

	// 0xa bytes for testing
	ResultTypeUnsafeSetConfig        = byte(0xa0)
	ResultTypeUnsafeStartCPUProfiler = byte(0xa1)
	ResultTypeUnsafeStopCPUProfiler  = byte(0xa2)
	ResultTypeUnsafeWriteHeapProfile = byte(0xa3)
	ResultTypeUnsafeFlushMempool     = byte(0xa4)
	ResultTypeCoreVersion            = byte(0xaf)

	// 0x9 bytes are for za_surveillance
	ResultTypeSurveillance = byte(0x90)
)

type RPCResult interface {
	rpctypes.Result
}

// for wire.readReflect
var _ = wire.RegisterInterface(
	struct{ RPCResult }{},
	wire.ConcreteType{&ResultGenesis{}, ResultTypeGenesis},
	wire.ConcreteType{&ResultBlockchainInfo{}, ResultTypeBlockchainInfo},
	wire.ConcreteType{&ResultBlockInfo{}, ResultTypeBlock},
	wire.ConcreteType{&ResultStatus{}, ResultTypeStatus},
	wire.ConcreteType{&ResultOrgs{}, ResultTypeOrgs},
	wire.ConcreteType{&ResultNetInfo{}, ResultTypeNetInfo},
	wire.ConcreteType{&ResultDialSeeds{}, ResultTypeDialSeeds},
	wire.ConcreteType{&ResultValidators{}, ResultTypeValidators},
	wire.ConcreteType{&ResultDumpConsensusState{}, ResultTypeDumpConsensusState},
	wire.ConcreteType{&ResultBroadcastTx{}, ResultTypeBroadcastTx},
	wire.ConcreteType{&ResultBroadcastTxCommit{}, ResultTypeBroadcastTxCommit},
	wire.ConcreteType{&ResultRequestSpecialOP{}, ResultTypeRequestSpecialOP},
	wire.ConcreteType{&ResultUnconfirmedTxs{}, ResultTypeUnconfirmedTxs},
	wire.ConcreteType{&ResultSubscribe{}, ResultTypeSubscribe},
	wire.ConcreteType{&ResultUnsubscribe{}, ResultTypeUnsubscribe},
	wire.ConcreteType{&ResultEvent{}, ResultTypeEvent},
	wire.ConcreteType{&ResultUnsafeSetConfig{}, ResultTypeUnsafeSetConfig},
	wire.ConcreteType{&ResultUnsafeProfile{}, ResultTypeUnsafeStartCPUProfiler},
	wire.ConcreteType{&ResultUnsafeProfile{}, ResultTypeUnsafeStopCPUProfiler},
	wire.ConcreteType{&ResultUnsafeProfile{}, ResultTypeUnsafeWriteHeapProfile},
	wire.ConcreteType{&ResultUnsafeFlushMempool{}, ResultTypeUnsafeFlushMempool},
	wire.ConcreteType{&ResultQuery{}, ResultTypeQuery},
	wire.ConcreteType{&ResultQueryNonce{}, ResultTypeQueryNonce},
	wire.ConcreteType{&ResultQueryBalance{}, ResultTypeQueryBalance},
	wire.ConcreteType{&ResultQueryShare{}, ResultTypeQueryShare},
	wire.ConcreteType{&ResultQueryReceipt{}, ResultTypeQueryReceipt},

	wire.ConcreteType{&ResultInfo{}, ResultTypeInfo},
	wire.ConcreteType{&ResultSurveillance{}, ResultTypeSurveillance},
	wire.ConcreteType{&ResultRefuseList{}, ResultTypeRefuseList},
	wire.ConcreteType{&ResultCoreVersion{}, ResultTypeCoreVersion},
	wire.ConcreteType{&ResultNonEmptyHeights{}, ResultTypeNonEmptyHeights},
)
